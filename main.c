/*----------------------------------------------------------------------*/
/* Copyright (C) 2014 David W. Vernooy

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
/*----------------------------------------------------------------------*/


#include <avr/io.h>
#include <stdio.h>
#include <stdlib.h>
#include <avr/pgmspace.h>
#include <avr/interrupt.h>
#include <string.h>
#include "suart.h"
#include "xitoa.h"
#include "ffconf.h"
#include "ff.h"
#include "diskio.h"
#include "lcd.h"
#include "VS1003B.h"
#include "read_id3.h"


/* Configurations */

#define SYSCLK 8000000UL	/* 8MHz internal osc */

#define DREQ bit_is_set(PINB,PB7)
#define ENABLE_XCS() PORTB&=~_BV(PB1)
#define DISABLE_XCS() PORTB|=_BV(PB1)
#define ENABLE_XDCS() PORTB&=~_BV(PB0)
#define DISABLE_XDCS() PORTB|=_BV(PB0)
#define ENABLE_XRESET() PORTB&=~_BV(PB6)
#define DISABLE_XRESET() PORTB|=_BV(PB6)
#define LED_OFF() PORTC&=~_BV(PC5)
#define LED_ON() PORTC|=_BV(PC5)

#define F_LEN	12 		/* File name tables */
#define D_LEN	10		/* Directory name tables*/

/* Playback control code generated by G-sensor control task */
#define K_NEXT			1
#define	K_PREV			2
#define	K_PAUSE			3
#define	K_PLAY			4
#define K_VOL_UP		6
#define	K_VOL_DOWN		7
#define K_ORDER			8
#define K_RANDOM		9
#define K_HELLO 		1

#define NEXT		bit_is_clear(PIND, PD2)
#define	PREV		bit_is_clear(PIND, PD3)
#define	PAUSE_PLAY	bit_is_clear(PIND, PD7)
#define VOL_DOWN	bit_is_clear(PIND, PD4)
#define	VOL_UP		bit_is_clear(PIND, PD5)
#define MODE 		bit_is_clear(PIND, PD6)



/*---------------------------------------------------------*/
/* Static Work Area                                        */
/*---------------------------------------------------------*/

/* File system object for logical drive and file object */
//FATFS fattyfs;
FIL fil;


//DWORD clmt[100];                    /* Cluster link map table buffer */

char TrackTbl[F_LEN];
char DirTbl[D_LEN];

volatile BYTE Tmr100, TmrMute;		/* 100Hz decrement timer */
volatile BYTE Playing;
volatile BYTE CmdPlay, CmdVol;
volatile BYTE CmdMode = K_RANDOM;		/* Play command */
volatile BYTE CmdVoltage, CmdVoltage1, CountVoltage;
volatile WORD MeasuredVoltage;
volatile DWORD TranslateVoltage;
BYTE AverageVoltCount;
WORD XXX,YYY, ZZZ, AAA;

BYTE VolumeArray[16] = {140,120,100,90,80,70,62,54,48,42,36,30,24,18,12,6};
BYTE VolumeIndex;


BYTE DivTmr;

WORD Voltage;
WORD CrcReg;		/* Card status ID */
UINT Cdir, Cdir_old, Ctrk;	/* Current album and track */
DWORD Volume = DefaultVolume;		/* Volume */
DWORD rand_val;
DWORD a_rand;
DWORD m_rand;
DWORD seed_rand;
WORD init_seed;
UINT rand_song;

UINT ntrks, ndirs, strk;


//interrupt stuff
BYTE blink = 0;
LONG pha = 0;
UINT squelch_count = 0;
BYTE trapped = 0;
BYTE squelched = 0;
BYTE stat = 0; //1 if playing status changed
BYTE trapped_voltage = 0;
BYTE frozen = 1;

  /* = "TAG" */
struct {
char title[42];

char artist[21];

char track_num_id3[10];
char length_id3[10];
    } info_id3v2v3;


/*--------------------------------------------------------------------------*/
/* Miscellaneous Controls                                                   */

DWORD acc_size;				/* Work register for fs command */
WORD acc_files, acc_dirs;
FILINFO Finfo;

FATFS Fatfs[_VOLUMES];		/* File system object for each logical drive */
BYTE Buff[512];			/* Working buffer */
BYTE Startfound;
WORD Zerocount;
WORD Readcount;
BYTE SkipCount;
BYTE AllZeros;

volatile WORD Timer;		/* 100Hz increment timer */


/********************************************************************************
Global Variables
********************************************************************************/
static FILE lcd_out = FDEV_SETUP_STREAM(lcd_chr_printf, NULL, _FDEV_SETUP_WRITE);

//Timer initialization offer seed of the srandom()
static
void Timer1_Initial(void)
{
 TCNT1H=0x00;
 TCNT1L=0x00;
 TCCR1A=0x00;//normal mode
 TCCR1B=0x01;//system clock;
}


static
BYTE get_cmd (void)
{
	BYTE c;
	cli();
	c = CmdPlay;
	if (stat ==1){

		lcd_goto_xy(1,6);
		if (Playing ==1) {
			fprintf_P(&lcd_out,PSTR("PLAY "));
		}
		else {
			invert = 1;
			fprintf_P(&lcd_out,PSTR("PAUSE"));
			invert = 0;
		}
		stat = 0;
	}
	if (CmdPlay != K_PAUSE) CmdPlay = 0;
	if (CmdVoltage ==1) {
		AverageVoltCount++;
		TranslateVoltage += (DWORD) MeasuredVoltage;
		CmdVoltage =0;
		if (AverageVoltCount > 9) {
			TranslateVoltage = TranslateVoltage/10;
			TranslateVoltage = (DWORD)500*TranslateVoltage;
			TranslateVoltage = TranslateVoltage/775;
			MeasuredVoltage = (WORD) TranslateVoltage;
			if (MeasuredVoltage > 1000) MeasuredVoltage = 999;
			XXX = MeasuredVoltage/100;
			YYY = MeasuredVoltage - 100*XXX;
			ZZZ = YYY/10;
			AAA = YYY-10*ZZZ;
			lcd_goto_xy(14,6);
			fprintf_P(&lcd_out,PSTR("%d.%d%d"),XXX,ZZZ,AAA);
			AverageVoltCount = 0;
			TranslateVoltage = 0;
		}
	}
	if (CmdVoltage1 ==1) {
		invert = 1;
		lcd_goto_xy(1,5);
		fprintf_P(&lcd_out,PSTR("LOW BATTERY"));
		invert = 0;
		CmdVoltage1 =0;
		CountVoltage = 0;
	}
	sei();
	return c;
}



static
void die (BYTE n)
{
//	LED_OFF();
	ENABLE_XRESET();
	xprintf(PSTR("die(%u)\n"), n);
}

/*--------------------------------------------------------------------------*/
/* Monitor                                                                  */

static
void xout(const char *label, const char *tag, int max)
{
  int i;
      xprintf(PSTR("\t%s\t"), label);
      for (i = 0; i < max && tag[i]; i++) xputc(tag[i]);
      xprintf(PSTR("\r\n"));
}

static
void Delay(uint16_t n)
{
 uint8_t j;
	for(j=0;j<2;j++) {
	while(n--) asm("nop");
	}
}


static
void IoInit (void)
{
	PORTB = 0b00000100;	/* u z H L H u */
	DDRB =  0b00101100;

	//DDRC |=  (1 << PC5);

	OCR0A = SYSCLK/64/2000-1;		/* Timer2: 4000Hz interval (OC0A)  */ //was 2000
	TCCR0A = 0b00000010;
	TCCR0B = 0b00000011;
	TIMSK0 = 0b00000010;	/* Enable TC0.oca interrupt */

	ADMUX = _BV(MUX2)|_BV(MUX0); //input on ADC5
	//ADMUX = _BV(MUX3)|_BV(MUX2)|_BV(MUX1); //measure 1.5V BG
	ADCSRA = _BV(ADEN)|_BV(ADPS2);


	sei();
}

static
void DisplayVolume (BYTE Volume)
{

//lcd_goto_xy(13,6);
//fprintf_P(&lcd_out,PSTR("%5d"), Volume);
lcd_goto_xy(18,6);

//invert = 1;
	if ((Volume>7) && (Volume<=11)) {
 		fprintf_P(&lcd_out,PSTR("%c%c%c%c"), 3, 7,Volume,32);
		lcd_goto_xy(20,5);
		fprintf_P(&lcd_out,PSTR("%c%c"), Volume-8, 32);
	}
	else if (Volume>11) {
 		fprintf_P(&lcd_out,PSTR("%c%c%c%c"), 3, 7,11,Volume-4);
		lcd_goto_xy(20,5);
		fprintf_P(&lcd_out,PSTR("%c%c"), 3, Volume-8);
	}
	else if ((Volume>3) && (Volume<=7)) {
 		fprintf_P(&lcd_out,PSTR("%c%c%c%c"), 3, Volume,32,32);
		lcd_goto_xy(20,5);
		fprintf_P(&lcd_out,PSTR("%c%c"), 32, 32);
	}
	else if (Volume<=3){
		fprintf_P(&lcd_out,PSTR("%c%c%c%c"), Volume, 32,32,32);
		lcd_goto_xy(20,5);
		fprintf_P(&lcd_out,PSTR("%c%c"), 32, 32);
	}

//invert = 0;
}

/*--------------------------------------------------------------------------*/
/*  File control                                                            */

/*
static
UINT get_dirs (char* dirname1) {		// Directory to be scanned

	BYTE res1;
	UINT s21;
	DIR dir1;
	FILINFO Finfo1;
	#if _USE_LFN
	char Lfname1[_MAX_LFN+1];
	#endif

	res1 = f_opendir(&dir1, dirname1);
	if (res1) { put_rc(res1);}
	s21 = 0;
	for(;;) {
		res1 = f_readdir(&dir1, &Finfo1);
		if ((res1 != FR_OK) || !Finfo1.fname[0]) break;
		if (Finfo1.fattrib & AM_DIR) {
			s21++;

		xprintf(PSTR("%s"), &(Finfo1.fname[0]));
		xputc('\n');
	    }
	}
	xputc('\n');
	f_closedir(&dir1);
	return(s21);
}

*/

static
UINT get_tracks (		// Number of found tracks
	char* dirname,		// Directory to be scanned
	BYTE mode, 			// 0:get filename, 1:Create Track List
	UINT TrackNumber
)
//buff 1 0 then buff 0 Ctrk
{
	UINT ntrks = 0;
	UINT ngood = 0;
	DIR dir;
	FILINFO fno;

	if (f_opendir(&dir, dirname) == FR_OK) {
		while (f_readdir(&dir, &fno) == FR_OK && fno.fname[0]) {
			if (fno.fattrib & AM_DIR) {
			}
			else {
				if ((strstr(fno.fname, ".MP3") ||strstr(fno.fname, ".mp3")) && !strstr(fno.fname, "~")) {
					if (mode ==0) {
						ngood++;
						if ((ngood-1) == TrackNumber) {
							strcpy(TrackTbl, fno.fname);
							ntrks++;
						}
					}
					if (mode ==1) {
						//xprintf(PSTR("%s"), &(fno.fname[0]));
						//xprintf(PSTR("\n"));
						ntrks++;
					}
				}
			}
		}
	}
	return ntrks;
}

static
UINT get_dirs( /* Number of found albums */
char* dir_name,
BYTE mode, // 0:get filename, 1:Create Track List
UINT DirNumber
)
{
	UINT ndirs = 0;
	UINT ngood = 0;
	DIR dir;
	FILINFO fno;

	if (f_opendir(&dir, dir_name) == FR_OK) {
		do {

			if (f_readdir(&dir, &fno) != FR_OK || !fno.fname[0]) break;
			if (mode==2) {
				if ((fno.fattrib & AM_DIR)) {
						ngood++;
						if ((ngood-1) == DirNumber) {
								strcpy(DirTbl, &(fno.fname[0]));
							}
				}
			}
			else {
				if ((fno.fattrib & AM_DIR) && get_tracks(fno.fname, 1,0)) {
					if (mode ==0) {
						ngood++;
						if ((ngood-1) == DirNumber) {
								strcpy(DirTbl, &(fno.fname[0]));
							}
					}
					if (mode ==1) {
						ndirs++;
						xprintf(PSTR("%s"), &(fno.fname[0]));
						xprintf(PSTR("\n"));
						if ((((ndirs-1)%6+1)==1) && (ndirs < 6))  {
						invert = 1;
						}
						lcd_goto_xy(1+11*((ndirs-1)/6), ((ndirs-1)%6+1));
						fprintf_P(&lcd_out,PSTR("%s"), &(fno.fname[0]));
						invert = 0;
					}
				}
			}
		} while (ndirs < 13);
	}
    f_closedir(&dir);

	return ndirs;
}



static
BYTE play_file (		// Terminated by: K_PREV, K_NEXT and 0(eof)
	const char* fname	// Audio file (mp3 or wav) to be played
)

{
	UINT br;
	BYTE cmd = 4;
	BYTE id3_read_status;
	FRESULT res;



    /***************************************************
	try to play a song
	****************************************************/
		for (UINT j = 1 ; j < 5 ; j++){
			if (j != 2){
			lcd_clear_line(j);
			}
		}


		res = f_open(&fil, fname, 1);
		if ( res != FR_OK ) {
		xprintf(PSTR("%d\r\n"), res);
		xputs(PSTR("f_open Error!!\r\n"));
		return 0;
		}


		strcpy_P(info_id3v2v3.artist, PSTR("Unknown Artist"));
		id3_read_status = read_ID3_info(ARTIST_ID3,info_id3v2v3.artist,sizeof(info_id3v2v3.artist),&fil);
		xout("artist", info_id3v2v3.artist, sizeof(info_id3v2v3.artist));
		lcd_goto_xy(1,1);
		fprintf_P(&lcd_out,PSTR("%s"), info_id3v2v3.artist);



		strcpy_P(info_id3v2v3.title, PSTR("Unknown Title"));
		id3_read_status = read_ID3_info(TITLE_ID3,info_id3v2v3.title,sizeof(info_id3v2v3.title),&fil);
		xout("title", info_id3v2v3.title, sizeof(info_id3v2v3.title));
		lcd_goto_xy(1,3);
		fprintf_P(&lcd_out,PSTR("%s"), info_id3v2v3.title);


	get_cmd();
	cmd = 0;

	/*find the start of MP3 file by searching for 0XFFFE*/

	Startfound = 0;
	Readcount = 0;
	Zerocount = 0;
	SkipCount = 1;
	AllZeros = 0;


	// Software reset
	VS1003B_WriteCMD(0, 0x0804);
	xputs(PSTR("Playing...\r\n"));
	//output the file information



	res = f_lseek(&fil, 0);
	/*
	fil.cltbl = clmt;                      // Enable fast seek function (cltbl != NULL)
    clmt[0] = 100;                      // Set table size
    res = f_lseek(&fil, CREATE_LINKMAP);     // Create CLMT
	*/

	//try first 500 bytes for traditional MP3 or simple MP3
	res = f_read(&fil, Buff, sizeof(Buff), &br);


	for (UINT i = 0 ; i < 511 ; i++){
		if ((Buff[i] == 0xFF) && ((Buff[i+1] == 0xFA) ||(Buff[i+1] == 0xFB)||(Buff[i+1] == 0xF3))) {
		Startfound = 1;
		res = f_lseek(&fil, f_tell(&fil) - i);
		goto SF;
		}
	}

SF:	if (Startfound ==0) res = f_lseek(&fil, 0);


	while ((!cmd) && (!Startfound)) {
		res = f_read(&fil, Buff, sizeof(Buff), &br);
		Readcount++;
		if (Readcount < 90) {
			if (Zerocount > 100) {
				for (UINT i = 0 ; i < 511 ; i++){
					if ((Buff[i] == 0xFF) && ((Buff[i+1] == 0xFA) ||(Buff[i+1] == 0xFB)||(Buff[i+1] == 0xF3))) {
						Startfound = 1;
						res = f_lseek(&fil, f_tell(&fil) - i);
						goto GC;
					}
				}
			}
			else {
				for (UINT i = 0 ; i < 509 ; i++){
					if (Buff[i] == 0x00){
						if(Buff[i+1] == 0x00) {
							Zerocount++;
						}
						if ((Zerocount > 100) && (Buff[i+2] ==0xFF)){
							if ((Buff[i+3] == 0xFA) ||(Buff[i+3] == 0xFB)) {
								Startfound = 1;
								res = f_lseek(&fil, f_tell(&fil) - i-1);
								goto GC;
							}
						}
						else {
							if ((Zerocount <=100) && ((Buff[i+1]) > 0x00)) Zerocount = 0;
						}
					}
				}
			}
		}
		else { //readcount > 40, go to more sophisticated search
			if ((SkipCount == 1) && (!(Buff[0] == 0))) {
				res = f_lseek(&fil, f_tell(&fil) +4096); //4096 assumes there are LOTS of buffered zeros in these long headers
				goto GC;
			}
			if (SkipCount ==0) {
				for (UINT i = 0 ; i < 511 ; i++){
					if ((Buff[i] == 0xFF) && ((Buff[i+1] == 0xFA) ||(Buff[i+1] == 0xFB)||(Buff[i+1] == 0xF3))) {
						Startfound = 1;
						res = f_lseek(&fil, f_tell(&fil) - i);
						goto GC;
					}
				}
			}
			if ((SkipCount ==1) && (Buff[0] ==0)) {
				AllZeros = 1;
				for (UINT i = 0 ; i < 10 ; i++){
					if ((!(Buff[5*i] ==0)) && (AllZeros = 1)) {
						AllZeros = 0;
					}
				}
				if (AllZeros ==1){
					AllZeros = 0;
					SkipCount = 0;
					goto GC;
				}
			}
		}
GC:		cmd = get_cmd();
	}




PF:
		while ((!cmd) && (!f_eof(&fil))){
			res = f_read(&fil, Buff, sizeof(Buff), &br);

			if (res != FR_OK)	{
				xputs(PSTR("f_read Error!!\r\n"));
				return 0;
			}

			if (CmdVol) {


				if (CmdVol == K_VOL_DOWN) {
					if (VolumeIndex == 0) {
						VolumeIndex = 0;
					}
					else {
						VolumeIndex = VolumeIndex -1;
					}

					Volume=(((WORD)VolumeArray[VolumeIndex]<<8)+(WORD)VolumeArray[VolumeIndex]);

					if(Volume>=0x8D8D) Volume=0x8D8D;
					else VS1003B_WriteCMD(0x0b,Volume);

					CmdVol = 0;
				}

				if (CmdVol == K_VOL_UP) {
					if (VolumeIndex ==15) {
						VolumeIndex = 15;
					}
					else{
						VolumeIndex = VolumeIndex +1;
					}

					Volume=(((WORD)VolumeArray[VolumeIndex]<<8)+(WORD)VolumeArray[VolumeIndex]);

					if(Volume<=0x0505) Volume=0x0505;
					else VS1003B_WriteCMD(0x0b,Volume);
					CmdVol = 0;

				}

			DisplayVolume(VolumeIndex);
			}

			for (UINT i = 0 ; i < 512 ; i++){
				while ((VS1003B_PIN & _BV(VS1003B_DREQ))==0); //wait
				VS1003B_WriteDAT(Buff[i]);
			}
		cmd = get_cmd();
		}

		while (cmd == K_PAUSE) cmd = get_cmd();
		if (cmd == K_PLAY) 	{
			cmd = 0;
			goto PF;
		}

	f_close(&fil);
	return cmd;
}


/*-----------------------------------------------------------------------*/
/* Main                                                                  */


int main (void)
{
	BYTE res;

	char buff[2];

    char fname[12];

	BYTE cmd, j;

	/***************************************************
	Initializations
    ****************************************************/
	IoInit();

	strcpy(buff, "/");
	// Setup LCD
	lcd_init();
	lcd_contrast(0x31);//0x40 for mp3 standalone; 0x3E for 3.3V, 0x31 for 5V

//	xfunc_out = uart_put;
	xfunc_out = xmit;
	xputs(PSTR("FatFs test for AVR\n"));
	xputs(_USE_LFN ? PSTR("LFN Enabled") : PSTR("LFN Disabled"));
	xprintf(PSTR(", Code page: %u\n"), _CODE_PAGE);

    Delay(0xffff);


	Delay(0xffff);

	//SPI initialize
	DDRB |= _BV(PB2)|_BV(PB3)|_BV(PB5);
    SPCR =   _BV(SPE)|_BV(MSTR);
	SPSR &= ~_BV(SPI2X);
	PORTB |=  _BV(PB2);
	PORTB |=  _BV(PB2);
	SPDR = 0xff;
	while(!(SPSR & _BV(SPIF)));

	//initialize the timer
	Timer1_Initial();


	Delay(0xffff);
	res = VS1003B_Init();
	//xprintf(PSTR("vs1003=%d\n"), res);


	Delay(0xffff);//supply enough delay


	res = disk_initialize(0); //sets SPI to high speed
	xprintf(PSTR("ini=%d\n"), res);
    if (!(res ==0)) {
		lcd_goto_xy(1,1);
		invert = 1;
		fprintf_P(&lcd_out,PSTR(" NO DISK FOUND "));
		invert = 0;
	}
	Delay(0xffff);								//wait for stable




	//FAT_Init();
	res = f_mount(&Fatfs[0],"/",1);
	if (res == 0) lcd_clear();


	xprintf(PSTR("mnt=%d\n"), res);
	Delay(0xffff);								//wait for stable

	a_rand = (DWORD) 29223;
	m_rand = (DWORD) 131071;
	seed_rand = (DWORD) 0;
	strk = 0; cmd = 0;
	CmdPlay = 0;
	CmdVol = 0;
	CmdVoltage = 0;
	CountVoltage = 0;
	Playing = 1;
	frozen = 1;


	ndirs = get_dirs(buff, 1, 0);
	Cdir = 0;

	get_dirs(buff, 0, Cdir);
	strcpy(fname, DirTbl);

	//2 scroll through & pick a directory

	while (!(CmdMode == K_ORDER)) {

		if ((CmdPlay == K_PREV) || (CmdPlay == K_NEXT)) {
			if (CmdPlay == K_NEXT) {	// Single tap of Previous
				Cdir_old = Cdir;
				CmdPlay = 0;
				if (Cdir == 0) {
					Cdir = ndirs-1;
				}
				else {
					Cdir = Cdir-1;
				}
			}

			if (CmdPlay == K_PREV) {	// Single tap of Next
				CmdPlay = 0;
				Cdir_old = Cdir;
				if (Cdir == (ndirs-1)) {
					Cdir = 0;
				}
				else {
					Cdir = Cdir+1;
				}
			}


			get_dirs(buff, 2, Cdir_old);
			strcpy(fname, DirTbl);
			lcd_goto_xy(1+11*(Cdir_old/6), (Cdir_old%6+1));
			fprintf_P(&lcd_out,PSTR("%s"), fname);

			get_dirs(buff, 2, Cdir);
			strcpy(fname, DirTbl);
			invert = 1;
			lcd_goto_xy(1+11*(Cdir/6), (Cdir%6+1));
			fprintf_P(&lcd_out,PSTR("%s"), fname);
			invert = 0;
		}
	}

	frozen = 0;
	//3 change to that directory
	f_chdir(&fname[0]);
	xprintf(PSTR("%s chosen\n"), fname);
	lcd_clear();

	/****** output to screen ********/
	lcd_goto_xy(1,6);
	fprintf_P(&lcd_out,PSTR("PLAY "));

	lcd_goto_xy(7,6);
	fprintf_P(&lcd_out,PSTR("ORDER "));

	TranslateVoltage = 0;
	//single conversion
	for (j=0;j<20;j++) {
	ADCSRA |= (1<<ADSC);
	while (ADCSRA & (1<<ADSC));
	MeasuredVoltage = ADC;
	TranslateVoltage += (DWORD)MeasuredVoltage;
	}
	TranslateVoltage = TranslateVoltage/20;
	TranslateVoltage = (DWORD)500*TranslateVoltage;
	TranslateVoltage = TranslateVoltage/775;
	MeasuredVoltage = (WORD) TranslateVoltage;
	if (MeasuredVoltage > 1000) MeasuredVoltage = 999;
	XXX = MeasuredVoltage/100;
	YYY = MeasuredVoltage - 100*XXX;
	ZZZ = YYY/10;
	AAA = YYY-10*ZZZ;
	TranslateVoltage = 0;

	lcd_goto_xy(14,6);
	fprintf_P(&lcd_out,PSTR("%d.%d%d"),XXX,ZZZ,AAA);

	VolumeIndex = 7;
	DisplayVolume(VolumeIndex);


	/*************/

	ntrks = get_tracks(".", 1, 0);	// Get tracks of current album
	xprintf(PSTR("ntrks %d \n"), ntrks);
	if (!ntrks) die(2);


	/***************************************************
	End Initializations
    ****************************************************/


		Ctrk = 0;
		for (;;) {
			get_tracks(".", 0, Ctrk); // get the track count
			strcpy(fname, TrackTbl);	// Play a track
			xprintf(PSTR("%s\n"), fname);
			invert = 1;
			lcd_clear_line(2);
			lcd_goto_xy(1,2);
			fprintf_P(&lcd_out,PSTR("%s %d/%d"),fname, Ctrk+1, ntrks);
			invert = 0;
			cmd = play_file(fname);
//			res = f_open(&fil, fname, 1);

			if(CmdMode==K_RANDOM) {//if the mode is shuffle the songs
				//lcd_goto_xy(7,6);
				//fprintf_P(&lcd_out,PSTR("SHUFFL"));
				if (seed_rand ==0) {
					init_seed = (WORD) TCNT1;
					seed_rand = (DWORD) init_seed;
				}
				seed_rand = (a_rand * seed_rand) % m_rand;
				rand_val = ((DWORD) ntrks*seed_rand)/m_rand;
				rand_song = (UINT) rand_val +1;
			}
			else {
			lcd_goto_xy(7,6);
			fprintf_P(&lcd_out,PSTR("ORDER "));
			}
			if (cmd == K_PREV) {	// Single tap of PREV
				if(CmdMode==K_RANDOM) {
				Ctrk = rand_song - 1;
				}
				else {
					if (--Ctrk >= ntrks) {
						Ctrk = ntrks - 1;
					}
				}
			}
			else {		// single tap of NEXT or EOF
				if(CmdMode==K_RANDOM) {
					Ctrk = rand_song - 1;
				}
				else{
					if (++Ctrk >= ntrks) {
						Ctrk = 0;
					}
				}
			}
		}


return 0;
}

/*---------------------------------------------------------*/
/* 2000Hz timer interrupt generated by OC0A                */
/*---------------------------------------------------------*/


ISR(TIMER0_COMPA_vect)
{
	pha++;

	if ((pha % (LONG) 20) == 0) {	/* 16 times per second */

		if (squelched == 1) {
			if (squelch_count < (UINT) 40) {
				squelch_count++;
			}
			else {
				squelch_count = 0;
				squelched = 0;
			}
		}
		if ((NEXT || PREV || PAUSE_PLAY || VOL_UP || VOL_DOWN || MODE) && (squelched == 0)) trapped++;


		if (trapped > (UINT) 5){
			if (NEXT) CmdPlay = K_NEXT;
			if (PREV) CmdPlay = K_PREV;
			if (PAUSE_PLAY) {
				stat = 1;
				if (Playing == 1){
					CmdPlay = K_PAUSE;
					Playing = 0;
				}
				else {
					CmdPlay = K_PLAY;
					Playing = 1;
				}
			}
			if (VOL_UP) CmdVol = K_VOL_UP;
			if (VOL_DOWN) CmdVol = K_VOL_DOWN;
			if (MODE) {
				if (CmdMode == K_RANDOM ){
					CmdMode = K_ORDER;
					if (frozen ==0) {
						lcd_goto_xy(7,6);
						fprintf_P(&lcd_out,PSTR("ORDER "));
					}
				}
				else {
					CmdMode = K_RANDOM;
					if (frozen ==0) {
						lcd_goto_xy(7,6);
						fprintf_P(&lcd_out,PSTR("SHUFFL"));
					}
				}
			}
		trapped = 0;
		squelched = 1;
		}
	}

	if ((pha % (long) 16000) == 0) {
		//single conversion
		ADCSRA |= (1<<ADSC);
		while (ADCSRA & (1<<ADSC));
		MeasuredVoltage = ADC;
		CmdVoltage = 1;
		if ((MeasuredVoltage < 510) && (CountVoltage >0)) CountVoltage = 0;
		if (MeasuredVoltage > 5100) {
			CountVoltage++;
			if (CountVoltage>10) {
				CountVoltage = 10;
				CmdVoltage1 = 1;
			}
		}
	}

}
